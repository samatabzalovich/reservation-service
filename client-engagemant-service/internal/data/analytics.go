package data

import (
	"database/sql"
	"fmt"
	"time"
)

type Wage struct {
	ServiceID  int64     `json:"service_id"`
	EmployeeID int64     `json:"employee_id"`
	InstID     int64     `json:"inst_id"`
	Price      int64     `json:"price"`
	StartDate  time.Time `json:"start_date"`
	EndDate    time.Time `json:"end_date"`
}

type Analytics struct {
	InstitutionID        int64   `json:"inst_id"`
	TotalAppointments    int     `json:"total_appointments"`
	CanceledAppointments int     `json:"canceled_appointments"`
	ServiceID            int64   `json:"service_id"`
	EmployeeID           int64   `json:"employee_id"`
	Rating               float32 `json:"rating"`
	Date                 int     `json:"date"`
}

// Employee with the highest client satisfaction scores

type AnalyticsModel struct {
	DB *sql.DB
}

// revenue generated by each institution for given date range

func (a *AnalyticsModel) TotalAppointmentsOfInstitutionForGivenDateRange(institutionID int64, startDate time.Time, endDate time.Time) (int, error) {
	stmt := `SELECT COUNT(*) FROM appointments WHERE institution_id = $1 AND created_at BETWEEN $2 AND $3`
	var totalAppointments int
	err := a.DB.QueryRow(stmt, institutionID, startDate, endDate).Scan(&totalAppointments)
	if err != nil {
		return 0, err
	}
	return totalAppointments, nil
}

func (a *AnalyticsModel) WageOfEmployeeServiceForGivenDateRange(employeeID int64, startDate time.Time, endDate time.Time) ([]*Wage, error) {
	stmt := `SELECT service_id,   COUNT(*) * s.price as wage FROM appointments a join services s on a.service_id = s.id WHERE employee_id = $1 AND a.end_time BETWEEN $2 AND $3 AND a.is_canceled = false  group by a.service_id, s.price`
	var wage []*Wage

	rows, err := a.DB.Query(stmt, employeeID, startDate, endDate)

	if err != nil {
		return nil, err
	}

	defer rows.Close()

	for rows.Next() {
		w := &Wage{}
		err := rows.Scan(&w.ServiceID, &w.Price)
		if err != nil {
			return nil, err
		}
		wage = append(wage, w)
	}
	return wage, nil
}

func (a *AnalyticsModel) TotalRevenueOfInstitutionForGivenDateRange(institutionID int64, startDate time.Time, endDate time.Time) (Wage, error) {
	stmt := `SELECT service_id, COUNT(*) * s.price as wage FROM appointments a join services s on a.service_id = s.id WHERE a.institution_id = $1 AND a.end_time BETWEEN $2 AND $3 group by a.service_id, s.price`
	var wage Wage
	err := a.DB.QueryRow(stmt, institutionID, startDate, endDate).Scan(&wage.Price)
	if err != nil {
		return Wage{}, err
	}
	return wage, nil
}

func (a *AnalyticsModel) TotalAppointmentsPerEmployeeForGivenDateRange(employeeID, institutionID int64, startDate time.Time, endDate time.Time) ([]*Analytics, error) {
	stmt := `SELECT employee_id, service_id, COUNT(*) as total_appointments FROM appointments WHERE employee_id = $1 AND  created_at BETWEEN $2 AND $3  AND institution_id = $4 group by employee_id, service_id`
	var totalAppointments []*Analytics

	rows, err := a.DB.Query(stmt, employeeID, startDate, endDate, institutionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	for rows.Next() {
		t := &Analytics{}
		err := rows.Scan(&t.EmployeeID, &t.ServiceID, &t.TotalAppointments)
		if err != nil {
			return nil, err
		}
		totalAppointments = append(totalAppointments, t)
	}
	if rows.Err() != nil {
		return nil, err
	}
	return totalAppointments, nil
}

func (a *AnalyticsModel) MostPopularAppointmentsBySelectedDate(institutionID int64, date string) ([]*Analytics, error) {
	stmt := fmt.Sprintf(`SELECT extract(%s FROM start_time) as extracted, COUNT(*) as total_appointments FROM appointments WHERE institution_id = $1 AND is_canceled =false group by extracted order by total_appointments desc`, date)
	var totalAppointments []*Analytics

	rows, err := a.DB.Query(stmt, institutionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	for rows.Next() {
		t := &Analytics{}
		err := rows.Scan(&t.Date, &t.TotalAppointments)
		if err != nil {
			return nil, err
		}
		totalAppointments = append(totalAppointments, t)
	}
	if rows.Err() != nil {
		return nil, err
	}
	return totalAppointments, nil
}

func (a *AnalyticsModel) MostPopularServicesByAppointments(serviceId, institutionId int64) ([]*Analytics, error) {
	stmt := `SELECT service_id, COUNT(*) as total_appointments FROM appointments WHERE service_id = $1 AND institution_id = $2 group by service_id order by total_appointments desc`
	var totalAppointments []*Analytics

	rows, err := a.DB.Query(stmt, serviceId, institutionId)

	if err != nil {
		return nil, err
	}

	defer rows.Close()

	for rows.Next() {
		t := &Analytics{}
		err := rows.Scan(&t.ServiceID, &t.TotalAppointments)
		if err != nil {
			return nil, err
		}
		totalAppointments = append(totalAppointments, t)
	}
	if rows.Err() != nil {
		return nil, err
	}
	return totalAppointments, nil
}

func (a *AnalyticsModel) GetCanceledAndTotalAppointmentsForGivenDateRange(institutionID int64, startDate time.Time, endDate time.Time) ([]*Analytics, error) {
	stmt := `SELECT COUNT(*) as total_appointments, COUNT(*) as canceled_appointments FROM appointments WHERE institution_id = $1 AND start_time BETWEEN $2 AND $3 AND is_canceled = true`
	var totalAppointments []*Analytics

	rows, err := a.DB.Query(stmt, institutionID, startDate, endDate)

	if err != nil {
		return nil, err
	}

	defer rows.Close()

	for rows.Next() {
		t := &Analytics{}
		err := rows.Scan(&t.TotalAppointments, &t.CanceledAppointments)
		if err != nil {
			return nil, err
		}
		totalAppointments = append(totalAppointments, t)
	}
	if rows.Err() != nil {
		return nil, err
	}
	return totalAppointments, nil
}

func (a *AnalyticsModel) EmployeeWithHighestRating(institutionID int64) ([]*Analytics, error) {
	stmt := `SELECT a.employee_id, avg(r.rating) as employeeRating FROM appointments a JOIN rating r ON  a.id = r.appointment_id WHERE a.institution_id = $1 GROUP BY a.employee_id ORDER BY employeeRating DESC`

	rows, err := a.DB.Query(stmt, institutionID)
	if err != nil {
		return nil, err
	}

	defer rows.Close()

	var employeeRatings []*Analytics

	for rows.Next() {
		t := &Analytics{}
		err := rows.Scan(&t.EmployeeID, &t.Rating)
		if err != nil {
			return nil, err
		}
		employeeRatings = append(employeeRatings, t)
	}
	if rows.Err() != nil {
		return nil, err
	}
	return employeeRatings, nil
}
